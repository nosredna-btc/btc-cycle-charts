<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bitcoin 4 Year Cycle Charts</title>
    <link rel="icon" href="assets/bitcoin.ico" type="image/x-icon">
    <style>
        /* Basic CSS variables for layout, colors, etc. */
        :root {
            --body-bg: #f0f0f0;
            --text-color: #333;
            --subtext-color: #555;
            --font-family: Arial, sans-serif;
            --chart-bg: #fff;
            --border-color: #ddd;
            --box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            --hover-shadow: 0 4px 8px rgba(0,0,0,0.2);
            --transition-speed: 0.3s;
            --chart-width: 400px;
            --chart-height: 290px;
            --single-chart-width: 800px;
            --single-chart-height: 600px;
            --caption-font-size: 14px;
            --single-caption-font-size: 18px;
            --nav-button-bg: #4CAF50;
            --nav-button-hover-bg: #45a049;
            --nav-button-active-bg: #357a38;
            --refresh-button-color: #4CAF50;
            --refresh-button-hover-color: #45a049;
            --page-text-color: #444;
            --page-text-bg: #fafafa;
            --page-text-padding: 20px;
            --page-text-border-radius: 8px;
            --page-text-box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            --page-text-margin-top: 20px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--body-bg);
            margin: 20px;
        }
        h1, h2, h3, h4, h5, h6 {
            text-align: center;
            color: var(--text-color);
        }
        #pageText h1,
        #pageText h2,
        #pageText h3,
        #pageText h4,
        #pageText h5,
        #pageText h6 {
            text-align: left;
            color: var(--text-color);
        }

        .navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .nav-button {
            padding: 8px 16px;
            background-color: var(--nav-button-bg);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color var(--transition-speed);
        }
        .nav-button:hover {
            background-color: var(--nav-button-hover-bg);
        }
        .nav-button.active {
            background-color: var(--nav-button-active-bg);
        }
        .nav-button:hover,
        .chart-item:hover,
        #refreshButton:hover {
            cursor: pointer;
        }

        .charts-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }
        .chart-item {
            background-color: var(--chart-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            box-shadow: var(--box-shadow);
            width: var(--chart-width);
            height: var(--chart-height);
            transition: box-shadow var(--transition-speed);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .charts-grid.single-chart .chart-item {
            width: var(--single-chart-width);
            height: var(--single-chart-height);
            margin: 0 auto;
            max-width: none;
        }
        .charts-grid.single-chart .chart-wrapper {
            flex: 0 0 500px;
        }
        .charts-grid.single-chart .caption {
            font-size: var(--single-caption-font-size);
        }
        .chart-wrapper {
            flex: 0 0 240px;
            background-color: var(--chart-bg);
            position: relative;
            overflow: hidden;
        }
        .chart-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
            transition: transform 0.2s ease;
        }
        .caption-wrapper {
            flex: 0 0 30px;
            display: flex;
            align-items: center;
        }
        .caption {
            width: 100%;
            text-align: center;
            font-size: var(--caption-font-size);
            color: var(--subtext-color);
        }
        .chart-item:hover {
            box-shadow: var(--hover-shadow);
        }
        .chart-item:hover img {
            transform: scale(1.02);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            z-index: 1000;
            backdrop-filter: blur(5px);
            cursor: pointer;
        }
        .modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90vh;
            position: relative;
            top: 50%;
            transform: translateY(-50%);
            cursor: default;
        }

        @media (max-width: 768px) {
            .charts-grid:not(.single-chart) .chart-item,
            .charts-grid:not(.single-chart) .chart-wrapper {
                width: 100%;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        #refreshButton {
            animation: pulse 2s infinite;
            transition: transform 0.2s ease, opacity 0.2s ease, color 0.3s ease;
            color: var(--refresh-button-color);
            background: none;
            border: none;
            cursor: pointer;
            margin-left: 8px;
            font-size: 12px;
            padding: 0;
        }
        #refreshButton:hover {
            color: var(--refresh-button-hover-color);
        }

        #pageText {
            background-color: var(--page-text-bg);
            color: var(--page-text-color);
            padding: var(--page-text-padding);
            border-radius: var(--page-text-border-radius);
            box-shadow: var(--page-text-box-shadow);
            margin-top: var(--page-text-margin-top);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.6;
        }
        #pageText img {
            max-width: 75%;
            height: auto;
        }
        #pageText h2, #pageText h3, #pageText h4 {
            color: var(--text-color);
        }
        #pageText ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        #pageText a {
            color: var(--nav-button-bg);
            text-decoration: none;
        }
        #pageText a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- Modal for enlarged chart -->
    <div id="imageModal" class="modal" aria-hidden="true" role="dialog">
        <img class="modal-content" id="modalImage" alt="Enlarged Chart">
    </div>

    <h1>Bitcoin 4 Year Cycle Charts</h1>

    <!-- Shows price + last updated time -->
    <div id="updateTime" style="text-align: center; margin-bottom: 20px; font-size: 16px; color: var(--subtext-color);">
        <!-- Populated by JS -->
    </div>

    <!-- Navigation buttons -->
    <div class="navigation">
        <button class="nav-button" data-page="1">Featured Chart</button>
        <button class="nav-button" data-page="2">Power Law Charts</button>
        <button class="nav-button" data-page="3">Quantiles Charts</button>
        <button class="nav-button" data-page="4">Days Ahead Charts</button>
        <button class="nav-button" data-page="5">All Charts</button>
    </div>

    <!-- Container for chart items -->
    <div id="chartContainer"></div>

    <!-- Additional textual content goes here -->
    <div id="pageText"></div>

    <script>
        const POLLING_INTERVAL = 10 * 60 * 1000; // 10 minutes
        let isPollingActive = false;  // Indicates if polling is active
        let currentPage = 1;
        let currentModalIndex = -1;
        let previousTimestamp = null;

        // Global flag to prevent multiple fetches
        let hasFetched = false;

        const pageConfigs = {
            1: { title: "Featured Chart", charts: ['powerlaw_chart1'] },
            2: { title: "Power Law Charts", charts: ['powerlaw_chart1', 'powerlaw_chart2', 'powerlaw_chart3'] },
            3: { title: "Quantiles Charts", charts: ['quantiles_chart1', 'quantiles_chart2', 'quantiles_chart3'] },
            4: { title: "Days Ahead Charts", charts: ['ghostly_days_chart1', 'ghostly_days_chart2', 'ghostly_days_chart3'] },
            5: {
                title: "All Charts",
                charts: [
                    'powerlaw_chart1', 'powerlaw_chart2', 'powerlaw_chart3',
                    'quantiles_chart1', 'quantiles_chart2', 'quantiles_chart3',
                    'ghostly_days_chart1', 'ghostly_days_chart2', 'ghostly_days_chart3'
                ]
            }
        };

        const chartData = {
            powerlaw_chart1: {
                alt: "Power Law / 4 year view",
                caption: "Power Law / 4 year view",
                date: "1 Jan 2024 through 31 Dec 2027",
                path: 'charts/bitcoin_cycles_2024_2027.png'
            },
            powerlaw_chart2: {
                alt: "Power Law / 2 year view",
                caption: "Power Law / 2 year view",
                date: "1 Jan 2024 through 31 Dec 2025",
                path: 'charts/bitcoin_cycles_2024_2025.png'
            },
            powerlaw_chart3: {
                alt: "Power Law / 1 year view",
                caption: "Power Law / 1 year view",
                date: `1 Jan ${new Date().getFullYear()} through 31 Dec ${new Date().getFullYear()}`,
                path: `charts/bitcoin_cycles_${new Date().getFullYear()}_powerlaw.png`
            },
            quantiles_chart1: {
                alt: "Quantiles / 4 year view",
                caption: "Quantiles / 4 year view",
                date: "1 Jan 2024 through 31 Dec 2027",
                path: 'charts/bitcoin_cycles_quantiles_2024_2027.png'
            },
            quantiles_chart2: {
                alt: "Quantiles / 2 year view",
                caption: "Quantiles / 2 year view",
                date: "1 Jan 2024 through 31 Dec 2025",
                path: 'charts/bitcoin_cycles_quantiles_2024_2025.png'
            },
            quantiles_chart3: {
                alt: "Quantiles / 1 year view",
                caption: "Quantiles / 1 year view",
                date: `1 Jan ${new Date().getFullYear()} through 31 Dec ${new Date().getFullYear()}`,
                path: `charts/bitcoin_cycles_${new Date().getFullYear()}_quantiles.png`
            },
            ghostly_days_chart1: {
                alt: 'Days Ahead / 4 year view',
                caption: 'Days Ahead / 4 year view',
                date: "1 Jan 2024 through 31 Dec 2027",
                path: 'charts/bitcoin_cycles_days_ahead_2024_2027.png'
            },
            ghostly_days_chart2: {
                alt: 'Days Ahead / 2 year view',
                caption: 'Days Ahead / 2 year view',
                date: "1 Jan 2024 through 31 Dec 2025",
                path: 'charts/bitcoin_cycles_days_ahead_2024_2025.png'
            },
            ghostly_days_chart3: {
                alt: 'Days Ahead / 1 year view',
                caption: 'Days Ahead / 1 year view',
                date: `1 Jan ${new Date().getFullYear()} through 31 Dec ${new Date().getFullYear()}`,
                path: `charts/bitcoin_cycles_${new Date().getFullYear()}_ghostly_days.png`
            }
        };

        // For storing preloaded images and page texts
        const loadedImages = {};
        let pageTexts = {};

        // DOM element references
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        const container = document.getElementById('chartContainer');
        const pageTextContainer = document.getElementById('pageText');


        async function fetchChartInfoIfNeeded(trigger = 'Unknown') {
            console.log(`[fetchChartInfoIfNeeded] Triggered by: ${trigger}`);

            // If a fetch is already in progress, exit early
            if (hasFetched) {
                console.warn('[fetchChartInfoIfNeeded] Fetch request ignored to prevent spamming.');
                return;
            }

            // Set the flag to indicate a fetch is in progress
            hasFetched = true;
            console.log('[fetchChartInfoIfNeeded] Fetch initiated. Setting hasFetched to true.');

            try {
                const fetchUrl = `charts/chart_info.json?v=${Date.now()}`;
                console.log(`[fetchChartInfoIfNeeded] Fetching data from: ${fetchUrl}`);
                const response = await fetch(fetchUrl);

                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }

                const data = await response.json();
                console.log('[fetchChartInfoIfNeeded] Fetch successful. Data received:', data);

                await handleChartInfo(data, trigger);
                return data;
            } catch (error) {
                console.error('[fetchChartInfoIfNeeded] Error fetching chart info:', error);
            } finally {
                hasFetched = false;
                console.log('[fetchChartInfoIfNeeded] Fetch completed. Setting hasFetched to false.');
            }
        }

        async function handleChartInfo(data, trigger) {
            // console.log(`[handleChartInfo] Handling chart info triggered by: ${trigger}`);
            const gmtTimestamp = data.timestamp_gmt;
            const price = parseFloat(data.current_price).toFixed(2);

            // On first load
            if (!previousTimestamp) {
                // console.log('[handleChartInfo] First load detected.');
                if (gmtTimestamp) {
                    const dateObj = new Date(gmtTimestamp);
                    if (!isNaN(dateObj)) {
                        document.getElementById('updateTime').innerHTML = getUpdateTimeHTML(dateObj, price);
                        previousTimestamp = gmtTimestamp;
                        // console.log(`[handleChartInfo] UpdateTime set to: ${document.getElementById('updateTime').innerHTML}`);
                    }
                }
            }
            // On subsequent loads
            else if (gmtTimestamp && gmtTimestamp !== previousTimestamp) {
                // console.log('[handleChartInfo] New data detected. Preparing to update.');
                previousTimestamp = gmtTimestamp; // Update the timestamp immediately to prevent multiple triggers
                const updateTimeElement = document.getElementById('updateTime');

                if (!updateTimeElement.querySelector('#refreshButton')) {
                    // console.log('[handleChartInfo] Refresh button not found. Creating new refresh button.');
                    const refreshButton = createRefreshButton();
                    
                    refreshButton.addEventListener('click', async () => {
                        // console.log('[handleChartInfo] Refresh button clicked.');
                        refreshButton.disabled = true; // Disable to prevent multiple clicks
                        refreshButton.innerText = 'Refreshing...';

                        try {
                            // Fetch the latest JSON data
                            const latestData = await fetchChartInfoIfNeeded('RefreshButton');

                            if (latestData && latestData.timestamp_gmt) {
                                const latestDateObj = new Date(latestData.timestamp_gmt);
                                const latestPrice = parseFloat(latestData.current_price).toFixed(2);
                                if (!isNaN(latestDateObj)) {
                                    document.getElementById('updateTime').innerHTML = getUpdateTimeHTML(latestDateObj, latestPrice);
                                    previousTimestamp = latestData.timestamp_gmt;
                                    
                                    // **Added Lines Below to Update Charts Immediately**
                                    await preloadImages();
                                    renderPage(currentPage);
                                    // **End of Added Lines**
                                }
                            }

                            // Remove the refresh button after successful refreshing
                            refreshButton.remove();
                            // console.log('[handleChartInfo] Refresh button removed after refreshing.');

                            // Restart polling
                            startEnhancedPolling();
                            // console.log('[handleChartInfo] Polling restarted after refreshing.');
                        } catch (error) {
                            console.error('[handleChartInfo] Error during refresh:', error);
                            // Re-enable the button and notify the user
                            refreshButton.disabled = false;
                            refreshButton.innerText = 'REFRESH';
                            alert('Failed to refresh. Please try again.');
                        }
                    });

                    updateTimeElement.appendChild(refreshButton);
                    // console.log('[handleChartInfo] Refresh button appended to updateTime element.');
                    stopEnhancedPolling();
                    // console.log('[handleChartInfo] Polling stopped after new data detected.');
                }
            }
        }

        // Helper functions
        function createRefreshButton() {
            // console.log('[createRefreshButton] Creating refresh button.');
            const refreshButton = document.createElement('button');
            refreshButton.id = 'refreshButton';
            refreshButton.innerText = 'REFRESH';
            refreshButton.style.marginLeft = '8px'; // Ensure it aligns with existing styles
            refreshButton.style.animation = 'pulse 2s infinite';
            refreshButton.style.transition = 'transform 0.2s ease, opacity 0.2s ease, color 0.3s ease';
            refreshButton.style.color = 'var(--refresh-button-color)';
            refreshButton.style.background = 'none';
            refreshButton.style.border = 'none';
            refreshButton.style.cursor = 'pointer';
            refreshButton.style.fontSize = '12px';
            refreshButton.style.padding = '0';
            return refreshButton;
        }

        function formatDateTime(dateObj) {
            return dateObj.toLocaleString('en-GB', {
                day: 'numeric',
                month: 'short',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true,
            }).replace(',', '');
        }

        function getUpdateTimeHTML(dateObj, price) {
            // console.log(`[getUpdateTimeHTML] Formatting update time: $${price} as of ${dateObj}`);
            return `
                Bitcoin price is <strong>$${price}</strong>
                as of <strong>${formatDateTime(dateObj)}</strong>
            `;
        }

        // Text content handling (Markdown processing remains unchanged)
        async function fetchAndParseText() {
            // console.log('[fetchAndParseText] Fetching and parsing text content.');
            try {
                const cacheBuster = `v=${Date.now()}`;
                const response = await fetch(`text.txt?${cacheBuster}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch text.txt');
                }
                const text = await response.text();
                // console.log('[fetchAndParseText] Text content fetched successfully.');
                parseText(text);
            } catch (error) {
                // console.error('[fetchAndParseText] Error fetching text content:', error);
                // Optionally, display a user-friendly message
                pageTextContainer.innerHTML = '<p>Unable to load additional information at this time.</p>';
            }
        }

        function parseText(text) {
            //console.log('[parseText] Parsing text content.');
            const pageHeaderRegex = /^Page\s+(\d+)\s+[—\-–]\s+(.+)$/i;
            const lines = text.split(/\r?\n/);
            let currentPageNumber = null;
            let currentPageContent = [];
            pageTexts = {};

            lines.forEach((line, index) => {
                const headerMatch = line.match(pageHeaderRegex);
                if (headerMatch) {
                    if (currentPageNumber !== null) {
                        pageTexts[currentPageNumber] = parseMarkdown(currentPageContent.join('\n').trim());
                        //console.log(`[parseText] Parsed content for Page ${currentPageNumber}.`);
                    }
                    currentPageNumber = parseInt(headerMatch[1]);
                    currentPageContent = [];
                    //console.log(`[parseText] Detected header for Page ${currentPageNumber}: ${headerMatch[2]}`);
                } else {
                    if (currentPageNumber !== null) {
                        currentPageContent.push(line);
                    }
                }
            });

            if (currentPageNumber !== null && currentPageContent.length > 0) {
                pageTexts[currentPageNumber] = parseMarkdown(currentPageContent.join('\n').trim());
                //console.log(`[parseText] Parsed content for Page ${currentPageNumber}.`);
            }
        }

        function parseMarkdown(markdownText) {
            //console.log('[parseMarkdown] Parsing markdown text.');
            const lines = markdownText.split(/\r?\n/);
            let html = '';
            let inList = false;
            let listType = '';
            let inTable = false;

            lines.forEach((line) => {
                let processedLine = line.trim();

                // Table handling
                if (processedLine.startsWith('|') && processedLine.endsWith('|')) {
                    const cells = processedLine.split('|').slice(1, -1).map(cell => cell.trim());
                    if (!inTable) {
                        html += '<table>\n';
                        inTable = true;
                        //console.log('[parseMarkdown] Started parsing a table.');
                    }
                    if (cells.every(cell => /^-+$/.test(cell))) {
                        html += '<thead>\n<tr>';
                        html += cells.map(() => '<th></th>').join('');
                        html += '</tr>\n</thead>\n<tbody>\n';
                        //console.log('[parseMarkdown] Detected table header.');
                    } else {
                        const rowTag = html.includes('<thead>') ? 'td' : 'th';
                        html += `<tr>${cells.map(cell => `<${rowTag}>${cell}</${rowTag}>`).join('')}</tr>\n`;
                        //console.log('[parseMarkdown] Added a table row.');
                    }
                    return;
                }
                if (inTable) {
                    html += '</tbody>\n</table>\n';
                    inTable = false;
                    //console.log('[parseMarkdown] Closed the table.');
                }

                // Inline formatting
                processedLine = processedLine
                    .replace(/\*\*\*(.*?)\*\*\*/g, '<strong><em>$1</em></strong>')
                    .replace(/___(.*?)___/g, '<strong><em>$1</em></strong>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/__(.*?)__/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/_(.*?)_/g, '<em>$1</em>')
                    .replace(/!\[(.*?)\]\((.*?)\)/g, '<img src="$2" alt="$1">')
                    .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');

                // Headings
                const headingMatch = processedLine.match(/^(#{1,6})\s+(.*)$/);
                if (headingMatch) {
                    const level = Math.min(headingMatch[1].length + 1, 6);
                    html += `<h${level}>${headingMatch[2]}</h${level}>\n`;
                    //console.log(`[parseMarkdown] Added heading level ${level}: ${headingMatch[2]}`);
                    return;
                }

                // Lists
                const ulMatch = processedLine.match(/^[-*+]\s+(.*)$/);
                if (ulMatch) {
                    if (!inList || listType !== 'ul') {
                        inList = true;
                        listType = 'ul';
                        html += `<ul>\n`;
                        //console.log('[parseMarkdown] Started an unordered list.');
                    }
                    html += `  <li>${ulMatch[1]}</li>\n`;
                    return;
                }
                const olMatch = processedLine.match(/^\d+\.\s+(.*)$/);
                if (olMatch) {
                    if (!inList || listType !== 'ol') {
                        inList = true;
                        listType = 'ol';
                        html += `<ol>\n`;
                        //console.log('[parseMarkdown] Started an ordered list.');
                    }
                    html += `  <li>${olMatch[1]}</li>\n`;
                    return;
                }

                // End list or empty line
                if (processedLine === '') {
                    if (inList) {
                        inList = false;
                        html += `</${listType}>\n`;
                        //console.log(`[parseMarkdown] Ended the ${listType} list.`);
                        listType = '';
                    }
                    return;
                }

                if (inList) {
                    inList = false;
                    html += `</${listType}>\n`;
                    //console.log(`[parseMarkdown] Ended the ${listType} list due to non-list item.`);
                    listType = '';
                }
                html += `<p>${processedLine}</p>\n`;
                //console.log(`[parseMarkdown] Added paragraph: ${processedLine}`);
            });

            if (inList) {
                html += `</${listType}>\n`;
                //console.log(`[parseMarkdown] Ended the ${listType} list at the end of markdown.`);
            }
            if (inTable) {
                html += '</tbody>\n</table>\n';
                //console.log('[parseMarkdown] Closed the table at the end of markdown.');
            }
            return html;
        }

        function handleImagesInPageText() {
            //console.log('[handleImagesInPageText] Handling images in page text.');
            const container = document.getElementById('pageText');
            const images = container.querySelectorAll('img');
            images.forEach(img => {
                img.addEventListener('load', () => {
                    const containerWidth = container.clientWidth;
                    if (img.naturalWidth > containerWidth) {
                        img.style.display = 'block';
                        img.style.margin = '0 auto';
                        //console.log('[handleImagesInPageText] Image resized to block and centered.');
                    } else {
                        img.style.display = 'inline-block';
                        img.style.margin = '0';
                        //console.log('[handleImagesInPageText] Image displayed inline.');
                    }
                });
            });
        }

        function displayPageText(pageNumber) {
            //console.log(`[displayPageText] Displaying text for Page ${pageNumber}.`);
            if (pageTexts[pageNumber]) {
                pageTextContainer.innerHTML = pageTexts[pageNumber];
                //console.log(`[displayPageText] Content for Page ${pageNumber} loaded.`);
            } else {
                pageTextContainer.innerHTML = '<p>No additional information available for this page.</p>';
                //console.log(`[displayPageText] No content available for Page ${pageNumber}.`);
            }
            handleImagesInPageText();
        }

        // Image preloading
        async function preloadImages() {
            //console.log('[preloadImages] Starting image preloading.');
            const timestamp = new Date().toISOString();
            const promises = Object.entries(chartData).map(([id, chart]) => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.src = `${chart.path}?v=${timestamp}`;
                    img.onload = () => {
                        //console.log(`[preloadImages] Image loaded: ${chart.path}`);
                        resolve();
                    };
                    img.onerror = (error) => {
                        console.error(`Error loading image ${chart.path}:`, error);
                        resolve(); // Resolve even on error to prevent blocking
                    };
                }).then(() => {
                    loadedImages[id] = `${chart.path}?v=${timestamp}`;
                });
            });
            await Promise.all(promises);
            //console.log('[preloadImages] All images preloaded.');
        }

        // Page rendering
        function renderPage(pageNumber) {
            //console.log(`[renderPage] Rendering Page ${pageNumber}.`);
            const config = pageConfigs[pageNumber];
            const isSingleChart = pageNumber === 1;

            container.innerHTML = `
                <h2>${config.title}</h2>
                <div class="charts-grid ${isSingleChart ? 'single-chart' : ''}">
                    ${config.charts.map(chartId => {
                        const chart = chartData[chartId];
                        return `
                            <div class="chart-item" data-chart-id="${chartId}">
                                <div class="chart-wrapper">
                                    <img src="${loadedImages[chartId] || ''}" alt="${chart.alt}">
                                </div>
                                <div class="caption-wrapper">
                                    <div class="caption">
                                        <strong>${chart.caption}</strong><br>
                                        ${chart.date}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;

            //console.log(`[renderPage] Page ${pageNumber} content injected into DOM.`);

            // Update active nav button
            document.querySelectorAll('.nav-button').forEach(button => {
                const isActive = parseInt(button.dataset.page) === pageNumber;
                button.classList.toggle('active', isActive);
                //console.log(`[renderPage] Nav button for Page ${button.dataset.page} set to ${isActive ? 'active' : 'inactive'}.`);
            });

            // Chart click handlers
            document.querySelectorAll('.chart-item').forEach((item, index) => {
                item.addEventListener('click', () => {
                    const chartId = item.getAttribute('data-chart-id');
                    //console.log(`[renderPage] Chart item clicked: ${chartId} at index ${index}.`);
                    openModal(index);
                });
            });

            // Display page text
            displayPageText(pageNumber);
        }

        // Modal handlers
        function openModal(index) {
            //console.log(`[openModal] Opening modal for chart index ${index}.`);
            const currentCharts = pageConfigs[currentPage].charts;
            if (index >= 0 && index < currentCharts.length) {
                currentModalIndex = index;
                const chartId = currentCharts[currentModalIndex];
                modalImg.src = loadedImages[chartId];
                modal.style.display = 'block';
                modal.setAttribute('aria-hidden', 'false');
                document.body.style.overflow = 'hidden';
                //console.log(`[openModal] Modal displayed with image: ${loadedImages[chartId]}`);
            } else {
                console.warn(`[openModal] Invalid chart index: ${index}. Modal not opened.`);
            }
        }

        function closeModal() {
            //console.log('[closeModal] Closing modal.');
            modal.style.display = 'none';
            modal.setAttribute('aria-hidden', 'true');
            currentModalIndex = -1;
            document.body.style.overflow = '';
            //console.log('[closeModal] Modal closed and body overflow restored.');
        }

        // Modal event listeners
        modal.addEventListener('click', () => {
            closeModal();
        });

        document.addEventListener('keydown', function(event) {
            if (modal.style.display === 'block') {
                const currentCharts = pageConfigs[currentPage].charts;
                switch (event.key) {
                    case 'Escape':
                    case ' ':
                    case 'Enter':
                        event.preventDefault();
                        //console.log(`[keydown] ${event.key} pressed. Closing modal.`);
                        closeModal();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        currentModalIndex = (currentModalIndex + 1) % currentCharts.length;
                        modalImg.src = loadedImages[currentCharts[currentModalIndex]];
                        //console.log(`[keydown] ArrowRight pressed. Showing next image: ${loadedImages[currentCharts[currentModalIndex]]}`);
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        currentModalIndex = (currentModalIndex - 1 + currentCharts.length) % currentCharts.length;
                        modalImg.src = loadedImages[currentCharts[currentModalIndex]];
                        //console.log(`[keydown] ArrowLeft pressed. Showing previous image: ${loadedImages[currentCharts[currentModalIndex]]}`);
                        break;
                }
            }
        });

        // Polling Implementation with Global Flag
        function initializePolling() {
            console.log('[initializePolling] Initializing polling mechanism.');
            let pollTimeoutId = null;
            let nextPollTime = Date.now() + POLLING_INTERVAL;

            const pollFunction = async () => {
                console.log('[pollFunction] Polling function called.');
                if (!isPollingActive) {
                    console.log('[pollFunction] Polling is inactive. Exiting.');
                    return;
                }

                try {
                    console.log('[pollFunction] Fetching chart info as part of polling.');
                    await fetchChartInfoIfNeeded('Polling');

                    if (isPollingActive) {
                        nextPollTime = Date.now() + POLLING_INTERVAL;
                        console.log(`[pollFunction] Next poll scheduled in ${POLLING_INTERVAL / 1000} seconds.`);
                        scheduleNextPoll();
                    }
                } catch (error) {
                    console.error('[pollFunction] Error during polling:', error);
                    scheduleNextPoll(); // Reschedule even on error
                }
            };

            function scheduleNextPoll() {
                if (pollTimeoutId) {
                    clearTimeout(pollTimeoutId);
                    console.log('[scheduleNextPoll] Existing poll timeout cleared.');
                }

                const timeUntilNextPoll = Math.max(0, nextPollTime - Date.now());
                console.log(`[scheduleNextPoll] Scheduling next poll in ${timeUntilNextPoll / 1000} seconds.`);
                pollTimeoutId = setTimeout(pollFunction, timeUntilNextPoll);
            }

            async function handleVisibilityChange() {
                console.log(`[handleVisibilityChange] Page visibility changed to: ${document.visibilityState}`);
                if (document.visibilityState === 'visible' && isPollingActive) {
                    console.log('[handleVisibilityChange] Page is visible and polling is active.');
                    if (pollTimeoutId) {
                        clearTimeout(pollTimeoutId);
                        console.log('[handleVisibilityChange] Existing poll timeout cleared due to visibility change.');
                    }

                    if (Date.now() >= nextPollTime) {
                        console.log('[handleVisibilityChange] Time to poll immediately after becoming visible.');
                        await pollFunction();
                    } else {
                        console.log('[handleVisibilityChange] Scheduling next poll based on remaining time.');
                        scheduleNextPoll();
                    }
                } else {
                    console.log('[handleVisibilityChange] Page is not visible or polling is inactive.');
                }
            }

            window.startEnhancedPolling = () => {
                if (isPollingActive) {
                    console.log('[startEnhancedPolling] Polling is already active. No action taken.');
                    return;
                }
                isPollingActive = true;
                nextPollTime = Date.now() + POLLING_INTERVAL;
                console.log(`[startEnhancedPolling] Polling started. Next poll at ${new Date(nextPollTime).toLocaleTimeString()}.`);
                scheduleNextPoll();
            };

            window.stopEnhancedPolling = () => {
                if (!isPollingActive) {
                    console.log('[stopEnhancedPolling] Polling is already inactive. No action taken.');
                    return;
                }
                isPollingActive = false;
                if (pollTimeoutId) {
                    clearTimeout(pollTimeoutId);
                    console.log('[stopEnhancedPolling] Polling stopped and existing timeout cleared.');
                    pollTimeoutId = null;
                }
            };

            document.addEventListener('visibilitychange', handleVisibilityChange);
            window.addEventListener('focus', handleVisibilityChange);

            window.addEventListener('beforeunload', () => {
                console.log('[beforeunload] Page is unloading. Stopping polling and removing event listeners.');
                stopEnhancedPolling();
                document.removeEventListener('visibilitychange', handleVisibilityChange);
                window.removeEventListener('focus', handleVisibilityChange);
            });
        }

        // Navigation button handlers
        document.querySelectorAll('.nav-button').forEach(button => {
            button.addEventListener('click', () => {
                const selectedPage = parseInt(button.dataset.page);
                console.log(`[nav-button] Navigation button clicked for Page ${selectedPage}.`);
                currentPage = selectedPage;
                renderPage(currentPage);
            });
        });

        // Page initialization
        async function refreshPage(trigger = 'Unknown') {
            console.log(`[refreshPage] Refreshing page triggered by: ${trigger}.`);
            await fetchChartInfoIfNeeded(trigger);
            await preloadImages();
            renderPage(currentPage);
            startEnhancedPolling();
            console.log('[refreshPage] Page refreshed and polling restarted.');
        }

        // Enhanced initialization
        window.addEventListener('DOMContentLoaded', () => {
            console.log('[DOMContentLoaded] DOM fully loaded and parsed. Initializing application.');
            let initPromise = null;

            const initialize = async () => {
                if (initPromise) {
                    console.log('[initialize] Initialization already in progress. Returning existing promise.');
                    return initPromise;
                }

                initPromise = (async () => {
                    try {
                        initializePolling();
                        console.log('[initialize] Polling mechanism initialized.');

                        // Sequential initialization
                        await fetchChartInfoIfNeeded('DOMContentLoaded');
                        console.log('[initialize] Chart info fetched during initialization.');

                        await fetchAndParseText();
                        console.log('[initialize] Text content fetched.');

                        await preloadImages();
                        console.log('[initialize] Images preloaded.');

                        renderPage(currentPage);
                        console.log(`[initialize] Page ${currentPage} rendered.`);

                        startEnhancedPolling();
                        console.log('[initialize] Polling started.');
                    } catch (error) {
                        console.error('[initialize] Initialization error:', error);
                        // Optionally, display a user-friendly message
                    } finally {
                        initPromise = null;
                        console.log('[initialize] Initialization process completed.');
                    }
                })();

                return initPromise;
            };

            initialize();
        });
    </script>

</body>
</html>
